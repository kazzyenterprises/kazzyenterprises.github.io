<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Order Page - Kazzy Enterprises</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  <style>
    section.order-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
    }
    section.order-form label,
    section.order-form select,
    section.order-form input {
      display: block;
      width: 100%;
      margin-bottom: 10px;
    }
    .row-with-button {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .row-with-button button {
      flex: 1;
      padding: 8px;
      font-size: 1rem;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .row-with-button button:hover { background-color: #5a6268; }
    .contact-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .contact-row label { display: flex; align-items: center; gap: 8px; }
    .contact-prefix { font-weight: bold; margin-right: 5px; white-space: nowrap; }
    #contact-no { width: 100px; }
    #order-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    #order-table th, #order-table td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
      vertical-align: middle;
    }
    .category-col { width: 30%; }
    .item-col { width: 30%; }
    .count-col { width: 10%; text-align: center; }
    .margin-col { width: 15%; }
    .mrp-col { width: 15%; }
    #order-table th:last-child, #order-table td:last-child {
      width: 1px;
      text-align: center;
    }
    .delete-btn {
      background: none;
      border: none;
      color: red;
      font-size: 1.2rem;
      cursor: pointer;
    }
    tfoot td {
      font-weight: bold;
      text-align: right;
      padding-top: 12px;
    }
    .button-row { display: flex; gap: 10px; }
    button.full-width-btn {
      flex: 1;
      padding: 12px;
      font-size: 1.2rem;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 10px;
    }
    button.full-width-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    button.full-width-btn:hover:not(:disabled) { background-color: #0056b3; }
  </style>
</head>
<body>
  <section class="order-form">
    <h1>üõí New Order</h1>

    <span id="order-id-display">Order ID: Generating...</span>

    <label>Order Date: <input type="date" id="order-date" readonly></label>
    <label>Order Time: <input type="time" id="order-time" readonly></label>

    <label>Select Route:
      <select id="route"></select>
    </label>

    <div class="row-with-button">
      <label style="flex: 1;">Select Place:
        <select id="place"></select>
      </label>
    </div>

    <div class="shop-details">
      <div class="row-with-button">
        <label style="flex: 0 0 60%;">Select Shop Name:
          <select id="shop-name"></select>
        </label>
      </div>
    </div>

      <a href="shop-management.html" target="_blank" class="manage-shop-link">
        üè™ Manage Shops & Places
      </a>

    <div id="order-sections">
      <table id="order-table">
        <thead>
          <tr>
            <th class="category-col">Product Category</th>
            <th class="item-col">Product Name</th>
            <th class="count-col">Order Qty</th>
            <th class="margin-col">Selling Price</th>
            <th class="mrp-col">MRP</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="order-tbody"></tbody>
        <tfoot>
          <tr>
            <td colspan="6" id="grand-total">Total: 0.00</td>
          </tr>
        </tfoot>
      </table>
    </div>

    <div class="button-row">
      <button id="add-product-row" class="full-width-btn">‚ûï Add Product Row</button>
    </div>

    <label>Delivery Date:
      <input type="date" id="delivery-date">
    </label>

    <button id="place-order" class="full-width-btn" style="display:none;">‚úÖ Submit Order</button>

    <div class="row-with-button">
      <button id="item-image-btn" type="button">üì∑ Product Image</button>
    </div>

    <h2>Add New Product to DB</h2>
    <label>Category: <input type="text" id="new-category"></label>
    <label>Product Name: <input type="text" id="new-product"></label>
    <button id="add-product">Add Product</button>
<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCI6ZLswuH7aZKpqt8EwGI6TWecpBQkVgo",
    authDomain: "kazzyenterprizes-c8ef7.firebaseapp.com",
    projectId: "kazzyenterprizes-c8ef7",
    storageBucket: "kazzyenterprizes-c8ef7.firebasestorage.app",
    messagingSenderId: "673988986305",
    appId: "1:673988986305:web:efbdc6283a30483f1a1b40",
    measurementId: "G-Z2W56NEGD6"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const USER_ID = "demo-user-1";

  let productCache = [];
  let placesCache = []; // { id: doc.id, name, ... }
  let draftOrderState = {
    routeId: "",
    placeId: "",
    placeName: "",
    shopId: "",
    shopName: "",
    deliveryDate: "",
    rows: []
  };

  // Elements (note: 'place' and 'shop-name' are <select> elements in this page)
  const orderDateInput = document.getElementById("order-date");
  const orderTimeInput = document.getElementById("order-time");
  const deliveryDateInput = document.getElementById("delivery-date");
  const routeSelect = document.getElementById("route");
  const placeSelect = document.getElementById("place");        // select for places
  const shopSelect = document.getElementById("shop-name");     // select for shops
  const orderIdDisplay = document.getElementById("order-id-display");
  const orderTbody = document.getElementById("order-tbody");
  const addProductRowBtn = document.getElementById("add-product-row");
  const placeOrderBtn = document.getElementById("place-order");
  const grandTotalCell = document.getElementById("grand-total");

  // Init
  window.addEventListener("DOMContentLoaded", async () => {
    // set order date/time defaults
    const now = new Date();
    orderDateInput.value = now.toISOString().split("T")[0];
    orderTimeInput.value = now.toTimeString().slice(0,5);
    const tomorrow = new Date(now); tomorrow.setDate(tomorrow.getDate() + 1);
    deliveryDateInput.value = tomorrow.toISOString().split("T")[0];

    // load products (for category/item selects)
    try {
      const productsSnap = await db.collection("products").get();
      productCache = productsSnap.docs.map(d => d.data());
    } catch (err) {
      console.error("Error fetching products:", err);
    }

    // load routes
    try {
      const routesSnap = await db.collection("routes").get();
      routesSnap.forEach(doc => {
        const opt = document.createElement("option");
        opt.value = doc.id;           // use doc.id (do NOT lowercase here)
        opt.textContent = doc.data().name || doc.id;
        routeSelect.appendChild(opt);
      });
      // pick a default route if none selected
      if (!routeSelect.value && routeSelect.options.length) {
        routeSelect.value = routeSelect.options[0].value;
      }
    } catch (err) {
      console.error("Error fetching routes:", err);
    }

    // load places for current route
    await fetchPlacesForSelectedRoute();

    // events
    routeSelect.addEventListener("change", async () => {
      await fetchPlacesForSelectedRoute();
    });
    placeSelect.addEventListener("change", fetchShopsForSelectedPlace);
    shopSelect.addEventListener("change", () => {
      // when shop changes we could set draftOrderState.shopId/shopName if needed
      // but we persist shop selection only when user adds rows / saves draft
    });

    // Load draft if exists and restore in proper order:
    try {
      const draftDoc = await db.collection("draftOrders").doc(USER_ID).get();
      if (draftDoc.exists) {
        // get the draft data first (we'll restore inputs after populating selects)
        draftOrderState = draftDoc.data();

        // If draft has a routeId and it's different than current selection, set it:
        if (draftOrderState.routeId) {
          routeSelect.value = draftOrderState.routeId;
        }

        // fetch places for this (possibly new) route and set place
        await fetchPlacesForSelectedRoute();

        // set place (prefer placeId if present)
        if (draftOrderState.placeId) {
          // only set if that option exists
          const hasOpt = [...placeSelect.options].some(o => o.value === draftOrderState.placeId);
          if (hasOpt) {
            placeSelect.value = draftOrderState.placeId;
          } else {
            // fallback: try to find by display name
            const found = placesCache.find(p => p.name === draftOrderState.placeName);
            if (found) placeSelect.value = found.id;
          }
        } else if (draftOrderState.placeName) {
          const found = placesCache.find(p => p.name === draftOrderState.placeName);
          if (found) placeSelect.value = found.id;
        }

        // fetch shops after place is set
        await fetchShopsForSelectedPlace();

        // set shop (prefer shopId if present)
        if (draftOrderState.shopId) {
          const hasShopOpt = [...shopSelect.options].some(o => o.value === draftOrderState.shopId);
          if (hasShopOpt) {
            shopSelect.value = draftOrderState.shopId;
          } else {
            // fallback by name
            const shopByName = [...shopSelect.options].find(o => o.textContent === draftOrderState.shopName);
            if (shopByName) shopSelect.value = shopByName.value;
          }
        } else if (draftOrderState.shopName) {
          const shopByName = [...shopSelect.options].find(o => o.textContent === draftOrderState.shopName);
          if (shopByName) shopSelect.value = shopByName.value;
        }

        // finally restore table rows
        restoreDraftToTable();
      }
    } catch (err) {
      console.error("Error loading draft order:", err);
    }

    await generateOrderId();
  });

  // ----------------- Places & Shops -----------------
  async function fetchPlacesForSelectedRoute() {
    try {
      // clear
      placeSelect.innerHTML = "";
      placesCache = [];

      const routeId = routeSelect.value;
      if (!routeId) return;

      const snap = await db.collection("places")
        .where("routeId", "==", routeId)
        .get();

      snap.forEach(doc => {
        const data = doc.data();
        placesCache.push({ id: doc.id, ...data });   // keep doc.id and data.name
        const opt = document.createElement("option");
        opt.value = doc.id;            // <-- doc.id (eg. 'kottayam_pallom')
        opt.textContent = data.name;   // human-friendly (eg. 'Pallom')
        placeSelect.appendChild(opt);
      });

      // if places found, pick first by default (unless draft had specific value, calling code may override)
      if (placesCache.length > 0 && !placeSelect.value) {
        placeSelect.value = placesCache[0].id;
      }

      // auto-fetch shops for selected place (if any)
      if (placeSelect.value) {
        await fetchShopsForSelectedPlace();
      }
    } catch (err) {
      console.error("Error fetching places:", err);
    }
  }

  async function fetchShopsForSelectedPlace() {
    try {
      shopSelect.innerHTML = "";

      const routeId = routeSelect.value;
      const placeId = placeSelect.value; // now this is doc.id (place doc id)

      if (!routeId || !placeId) {
        // show placeholder option
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Select route & place";
        shopSelect.appendChild(opt);
        return;
      }

      // debug
      console.debug("Fetching shops for", { routeId, placeId });

      const snap = await db.collection("shops")
        .where("routeId", "==", routeId)
        .where("placeId", "==", placeId)
        .get();

      if (snap.empty) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No shops found";
        shopSelect.appendChild(opt);
        console.debug("No shops found for", { routeId, placeId });
        return;
      }

      snap.forEach(doc => {
        const data = doc.data();
        const opt = document.createElement("option");
        opt.value = doc.id;        // <-- shop doc id (eg. 'kottayam_pallom_nice_bakery')
        opt.textContent = data.name; // friendly name
        shopSelect.appendChild(opt);
      });

      console.debug(`Found ${shopSelect.options.length} shops for placeId=${placeId}`);
    } catch (err) {
      console.error("Error fetching shops:", err);
    }
  }

  // ----------------- Draft Save / Restore -----------------
  function restoreDraftToTable() {
    orderTbody.innerHTML = "";
    if (!draftOrderState.rows?.length) return;
    draftOrderState.rows.forEach(row => createRow(row));
    updateGrandTotal();
    if (draftOrderState.rows.length) placeOrderBtn.style.display = "block";
  }

  async function saveDraftToFirestore() {
    // clean rows (no empty rows)
    const cleanRows = draftOrderState.rows.filter(r =>
      r.productCategory && r.productName && r.orderQuantity > 0
    );

    const placeId = placeSelect.value || "";
    const placeName = placeSelect.options[placeSelect.selectedIndex]?.textContent || "";
    const shopId = shopSelect.value || "";
    const shopName = shopSelect.options[shopSelect.selectedIndex]?.textContent || "";

    const draftData = {
      routeId: routeSelect.value || "",
      placeId,
      placeName,
      shopId,
      shopName,
      deliveryDate: deliveryDateInput.value,
      rows: cleanRows,
      lastUpdated: new Date().toISOString()
    };

    // only write if changed (reduces writes)
    if (JSON.stringify(draftData) !== JSON.stringify(draftOrderState)) {
      draftOrderState = draftData;
      try {
        await db.collection("draftOrders").doc(USER_ID).set(draftData);
        console.debug("Saved draftOrder", draftData);
      } catch (err) {
        console.error("Error saving draft:", err);
      }
    }
  }

  // ----------------- Products / Rows -----------------
  function getProduct(category, itemName) {
    return productCache.find(p => p.category === category && p.name === itemName);
  }

  function createRow(rowData = {}) {
    const tr = document.createElement("tr");
    tr.className = "order-category";

    const categories = [...new Set(productCache.map(p => p.category))];

    // category select
    const categorySelect = document.createElement("select");
    categories.forEach(cat => {
      const opt = document.createElement("option");
      opt.value = cat;
      opt.textContent = cat;
      categorySelect.appendChild(opt);
    });
    categorySelect.value = rowData.productCategory || categories[0] || "";

    // item select
    const itemSelect = document.createElement("select");
    populateItems(categorySelect.value, itemSelect);
    itemSelect.value = rowData.productName || "";

    // qty, price, mrp
    const countInput = document.createElement("input");
    countInput.type = "number";
    countInput.className = "count-input";
    countInput.max = 999;
    countInput.step = 1;
    countInput.value = rowData.orderQuantity ?? "";

    const marginInput = document.createElement("input");
    marginInput.type = "number";
    marginInput.className = "margin-input";
    marginInput.step = "0.01";
    marginInput.value = rowData.sellingPrice ?? "";

    const mrpInput = document.createElement("input");
    mrpInput.type = "number";
    mrpInput.className = "mrp-input";
    mrpInput.step = "0.01";
    mrpInput.value = rowData.mrp ?? "";

    // listeners
    categorySelect.addEventListener("change", () => {
      populateItems(categorySelect.value, itemSelect);
      itemSelect.value = "";
      marginInput.value = "";
      mrpInput.value = "";
      updateDraftState();
    });

    itemSelect.addEventListener("change", () => {
      const selectedProduct = getProduct(categorySelect.value, itemSelect.value);
      if (selectedProduct) {
        marginInput.value = selectedProduct.defaultMarginPrice ?? "";
        mrpInput.value = selectedProduct.mrp ?? "";
      }
      updateDraftState();
    });

    countInput.addEventListener("input", updateDraftState);
    marginInput.addEventListener("input", updateDraftState);
    mrpInput.addEventListener("input", updateDraftState);

    // delete
    const deleteTd = document.createElement("td");
    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.className = "delete-btn";
    deleteBtn.innerHTML = "üóëÔ∏è";
    deleteBtn.addEventListener("click", async () => {
      tr.remove();
      updateDraftState();
      await saveDraftToFirestore();
    });
    deleteTd.appendChild(deleteBtn);

    // append cells
    tr.appendChild(createTd(categorySelect, "category-col"));
    tr.appendChild(createTd(itemSelect, "item-col"));
    tr.appendChild(createTd(countInput, "count-col"));
    tr.appendChild(createTd(marginInput, "margin-col"));
    tr.appendChild(createTd(mrpInput, "mrp-col"));
    tr.appendChild(deleteTd);

    orderTbody.appendChild(tr);
  }

  function createTd(el, cls = "") {
    const td = document.createElement("td");
    if (cls) td.className = cls;
    td.appendChild(el);
    return td;
  }

  function populateItems(category, selectEl) {
    selectEl.innerHTML = "";
    const items = productCache.filter(p => p.category === category);
    items.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p.name;
      opt.textContent = p.name;
      selectEl.appendChild(opt);
    });
  }

  function updateDraftState() {
    draftOrderState.rows = [];
    document.querySelectorAll("tr.order-category").forEach(tr => {
      const selects = tr.querySelectorAll("select");
      const inputs = tr.querySelectorAll("input");

      const productCategory = selects[0].value;
      const productName = selects[1].value;
      const orderQuantity = parseInt(inputs[0].value, 10) || 0;
      const sellingPrice = parseFloat(inputs[1].value) || 0;
      const mrp = parseFloat(inputs[2].value) || 0;

      if (productName && orderQuantity > 0) {
        draftOrderState.rows.push({
          productCategory,
          productName,
          orderQuantity,
          sellingPrice,
          mrp,
          lineTotal: orderQuantity * sellingPrice
        });
      }
    });

    updateGrandTotal();
  }

  function updateGrandTotal() {
    let total = 0;
    draftOrderState.rows.forEach(r => total += (r.lineTotal || 0));
    grandTotalCell.textContent = "Total: " + total.toFixed(2);
  }

  // Add row button (prevents multiple blank rows)
  addProductRowBtn.addEventListener("click", async () => {
    const lastTr = orderTbody.lastElementChild;
    if (lastTr) {
      const selects = lastTr.querySelectorAll("select");
      const inputs = lastTr.querySelectorAll("input");
      const lastProduct = selects[1]?.value || "";
      const lastQty = parseInt(inputs[0]?.value, 10) || 0;
      if (!lastProduct || lastQty <= 0) {
        return alert("‚ö†Ô∏è Please fill the existing row before adding a new one.");
      }
    }
    createRow();
    updateDraftState();
    await saveDraftToFirestore();
    placeOrderBtn.style.display = "block";
  });

  // Place order
  placeOrderBtn.addEventListener("click", async () => {
    const orderId = orderIdDisplay.dataset.orderId;
    if (!orderId) return alert("Missing Order ID. Try again.");
    if (!draftOrderState.rows.length) return alert("No items to place order.");

    const selectedPlaceName = placeSelect.options[placeSelect.selectedIndex]?.textContent || "";
    const selectedShopName = shopSelect.options[shopSelect.selectedIndex]?.textContent || "";

    await db.collection("orders").doc(orderId).set({
      orderId: orderId, // SEP28-0001 format
      userId: USER_ID,
      orderDate: orderDateInput.value,
      orderTime: orderTimeInput.value,
      deliveryDate: deliveryDateInput.value,
      routeId: routeSelect.value,
      placeId: placeSelect.value,
      placeName: selectedPlaceName,
      shopId: shopSelect.value,
      shopName: selectedShopName,
      items: draftOrderState.rows.map(r => ({ ...r, lineTotal: r.orderQuantity * r.sellingPrice })),
      total: draftOrderState.rows.reduce((sum, r) => sum + (r.orderQuantity * r.sellingPrice), 0),
      status: "pending",
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    });

    await db.collection("draftOrders").doc(USER_ID).delete();

    alert("‚úÖ Order placed successfully!");
    location.reload();
  });

  // Order id generator (prefix-####)
  async function generateOrderId() {
    const now = new Date();
    const month = now.toLocaleString('en-US', { month: 'short' }).toUpperCase();
    const day = String(now.getDate()).padStart(2, "0");
    const prefix = `${month}${day}`;

    const snap = await db.collection("orders")
      .orderBy("createdAt", "desc")
      .limit(50)
      .get();

    let count = 0;
    snap.forEach(doc => {
      if (doc.id.startsWith(prefix)) {
        const num = parseInt(doc.id.split("-")[1]) || 0;
        count = Math.max(count, num);
      }
    });

    const orderId = `${prefix}-${String(count + 1).padStart(4, "0")}`;
    orderIdDisplay.dataset.orderId = orderId;
    orderIdDisplay.textContent = `Order ID: ${orderId}`;
  }
</script>

</body>
</html>
