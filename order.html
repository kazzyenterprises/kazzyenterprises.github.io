<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Order Page - Kazzy Enterprises</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  <style>
    section.order-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 900px;
      margin: 0 auto;
    }

    section.order-form label,
    section.order-form select,
    section.order-form input {
      display: block;
      width: 100%;
      margin-bottom: 10px;
    }

    /* Table Styling */
    #order-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    #order-table th,
    #order-table td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
      vertical-align: middle;
    }

    /* Column ratios (user requested) */
    .category-col { width: 30%; }
    .item-col     { width: 30%; }
    .count-col    { width: 10%; text-align: center; }
    .margin-col   { width: 15%; }
    .mrp-col      { width: 15%; }

    /* Delete Button Column kept minimal so it does not affect ratios */
    #order-table th:last-child,
    #order-table td:last-child {
      width: 1px;
      text-align: center;
    }

    .delete-btn {
      background: none;
      border: none;
      color: red;
      font-size: 1.2rem;
      cursor: pointer;
    }

    tfoot td {
      font-weight: bold;
      text-align: right;
      padding-top: 12px;
    }

    @media (max-width: 767px) {
      #order-table {
        display: block;
        overflow-x: auto;
      }
    }
  </style>
</head>
<body>
  <section class="order-form">
    <h1>Place Order</h1>

    <!-- Auto-Filled Date and Time -->
    <label>Date: <input type="date" id="order-date" readonly></label>
    <label>Time: <input type="time" id="order-time" readonly></label>

    <!-- Route Dropdown -->
    <label>Route:
      <select id="route">
        <option value="">Select Route</option>
        <option value="Route 1">Route 1</option>
        <option value="Route 2">Route 2</option>
        <option value="Route 3">Route 3</option>
      </select>
    </label>

    <label>Place: <input type="text" id="place"></label>
    <label>Shop Name: <input type="text" id="shop-name"></label>

    <div id="order-sections">
      <table id="order-table">
        <thead>
          <tr>
            <th class="category-col">Category</th>
            <th class="item-col">Item</th>
            <th class="count-col">Count</th>
            <th class="margin-col">Margin Rate</th>
            <th class="mrp-col">Actual MRP</th>
            <th></th> <!-- delete column (keeps its own small space) -->
          </tr>
        </thead>

        <tbody id="order-tbody"></tbody>

        <tfoot>
          <!-- Grand total row at the end (spans all table columns) -->
          <tr>
            <td colspan="6" id="grand-total">Total: 0.00</td>
          </tr>
        </tfoot>
      </table>
    </div>

    <button id="add-category">Add Category & Item</button>

    <!-- Expected Delivery Date -->
    <label>Expected Delivery Date: <input type="date" id="delivery-date"></label>

    <button id="place-order" style="display:none;">Place Order</button>

    <h2>Add New Product to DB</h2>
    <label>Category: <input type="text" id="new-category"></label>
    <label>Product Name: <input type="text" id="new-product"></label>
    <button id="add-product">Add Product</button>
  </section>

  <script>
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_PROJECT_ID.appspot.com",
      messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
      appId: "YOUR_APP_ID"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // Auto-fill Date, Time, and Delivery Date (+1 day)
    window.addEventListener("DOMContentLoaded", () => {
      const now = new Date();
      const orderDateInput = document.getElementById("order-date");
      const orderTimeInput = document.getElementById("order-time");
      const deliveryDateInput = document.getElementById("delivery-date");

      orderDateInput.value = now.toISOString().split("T")[0];
      orderTimeInput.value = now.toTimeString().slice(0, 5);

      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      deliveryDateInput.value = tomorrow.toISOString().split("T")[0];
    });

    const orderTbody = document.getElementById("order-tbody");
    const addCategoryBtn = document.getElementById("add-category");
    const placeOrderBtn = document.getElementById("place-order");
    const grandTotalCell = document.getElementById("grand-total");

    // helper to create td with optional class
    const createTd = (el, cls = "") => {
      const td = document.createElement("td");
      if (cls) td.className = cls;
      td.appendChild(el);
      return td;
    };

    // enforce integer 1..999 for count input
    function enforceCountBounds(input) {
      let v = Number(input.value);
      if (!Number.isFinite(v) || isNaN(v)) v = 1;
      v = Math.floor(v);
      if (v < 1) v = 1;
      if (v > 999) v = 999;
      input.value = v;
    }

    // compute grand total (sum of count * margin)
    function updateGrandTotal() {
      let total = 0;
      document.querySelectorAll("tr.order-category").forEach(tr => {
        const countEl = tr.querySelector(".count-input");
        const marginEl = tr.querySelector(".margin-input");
        const count = parseInt(countEl?.value || 0, 10) || 0;
        const margin = parseFloat(marginEl?.value || 0) || 0;
        total += count * margin;
      });
      grandTotalCell.textContent = "Total: " + total.toFixed(2);
    }

    addCategoryBtn.addEventListener("click", async () => {
      // fetch distinct categories from products collection
      const categoriesSnap = await db.collection("products").get();
      const categories = [...new Set(categoriesSnap.docs.map(d => d.data().category))];

      const tr = document.createElement("tr");
      tr.className = "order-category";

      const categorySelect = document.createElement("select");
      categorySelect.className = "category-select";
      categories.forEach(cat => {
        const opt = document.createElement("option");
        opt.value = cat;
        opt.textContent = cat;
        categorySelect.appendChild(opt);
      });

      const itemSelect = document.createElement("select");
      itemSelect.className = "item-select";

      const countInput = document.createElement("input");
      countInput.type = "number";
      countInput.className = "count-input";
      countInput.min = 1;
      countInput.max = 999;
      countInput.step = 1;
      countInput.value = 1;

      const marginInput = document.createElement("input");
      marginInput.type = "number";
      marginInput.className = "margin-input";
      marginInput.step = "0.01";

      const mrpInput = document.createElement("input");
      mrpInput.type = "number";
      mrpInput.className = "mrp-input";
      mrpInput.step = "0.01";

      // populate items for the initial category and on category change
      const updateItems = async () => {
        itemSelect.innerHTML = "";
        const cat = categorySelect.value;
        const itemsSnap = await db.collection("products").where("category", "==", cat).get();
        itemsSnap.forEach(doc => {
          const opt = document.createElement("option");
          opt.value = doc.data().name;
          opt.textContent = doc.data().name;
          itemSelect.appendChild(opt);
        });
        await updateProductDetails();
      };

      // set margin and mrp from product doc if present
      const updateProductDetails = async () => {
        const cat = categorySelect.value;
        const item = itemSelect.value;
        const productSnap = await db.collection("products")
          .where("category", "==", cat)
          .where("name", "==", item)
          .get();
        if (!productSnap.empty) {
          const data = productSnap.docs[0].data();
          marginInput.value = (data.margin != null) ? data.margin : "";
          mrpInput.value = (data.mrp != null) ? data.mrp : "";
        }
        updateGrandTotal();
      };

      // event listeners
      categorySelect.addEventListener("change", updateItems);
      itemSelect.addEventListener("change", updateProductDetails);

      // ensure integer counts and update total
      countInput.addEventListener("input", () => {
        enforceCountBounds(countInput);
        updateGrandTotal();
      });
      countInput.addEventListener("blur", () => {
        enforceCountBounds(countInput);
        updateGrandTotal();
      });

      // margin change updates total
      marginInput.addEventListener("input", updateGrandTotal);
      marginInput.addEventListener("blur", updateGrandTotal);

      await updateItems(); // populate items initially

      // build row cells (classes on <td> match ratios)
      tr.appendChild(createTd(categorySelect, "category-col"));
      tr.appendChild(createTd(itemSelect, "item-col"));
      tr.appendChild(createTd(countInput, "count-col"));
      tr.appendChild(createTd(marginInput, "margin-col"));
      tr.appendChild(createTd(mrpInput, "mrp-col"));

      // delete button cell (keeps own small space, does not affect ratios)
      const deleteTd = document.createElement("td");
      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "delete-btn";
      deleteBtn.innerHTML = "ðŸ—‘ï¸";
      deleteBtn.addEventListener("click", () => {
        tr.remove();
        updateGrandTotal();
        // hide place order if no rows remain
        if (orderTbody.querySelectorAll("tr.order-category").length === 0) {
          placeOrderBtn.style.display = "none";
        }
      });
      deleteTd.appendChild(deleteBtn);
      tr.appendChild(deleteTd);

      orderTbody.appendChild(tr);
      placeOrderBtn.style.display = "block";
      updateGrandTotal();
    });

    // Add product to DB (unchanged)
    document.getElementById("add-product").addEventListener("click", async () => {
      const newCategory = document.getElementById("new-category").value.trim();
      const newProduct = document.getElementById("new-product").value.trim();
      if (newCategory && newProduct) {
        await db.collection("products").add({ category: newCategory, name: newProduct });
        alert("Product added to database.");
        document.getElementById("new-category").value = "";
        document.getElementById("new-product").value = "";
      }
    });

    // Place order (unchanged, but collects only existing order-category rows)
    placeOrderBtn.addEventListener("click", async () => {
      const date = document.getElementById("order-date").value;
      const time = document.getElementById("order-time").value;
      const route = document.getElementById("route").value;
      const place = document.getElementById("place").value;
      const shop = document.getElementById("shop-name").value;
      const deliveryDate = document.getElementById("delivery-date").value;
      const orders = [];

      document.querySelectorAll("tr.order-category").forEach(tr => {
        const selects = tr.querySelectorAll("select");
        const inputs = tr.querySelectorAll("input");
        // selects[0] = category, selects[1] = item
        // inputs[0] = count, inputs[1] = margin, inputs[2] = mrp (order preserved)
        orders.push({
          category: selects[0]?.value || "",
          item: selects[1]?.value || "",
          count: parseInt(inputs[0]?.value || 0, 10),
          margin: parseFloat(inputs[1]?.value || 0),
          mrp: parseFloat(inputs[2]?.value || 0)
        });
      });

      if (!route || !shop || !place || !deliveryDate || orders.length === 0) {
        alert("Please fill all fields and add at least one order item.");
        return;
      }

      await db.collection("orders").add({
        date,
        time,
        route,
        shop,
        place,
        deliveryDate,
        orders,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });

      alert("Order placed successfully!");
      location.reload();
    });
  </script>
</body>
</html>
